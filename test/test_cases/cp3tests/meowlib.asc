
################################################################################
# abs(x) - returns the absolute value of x
################################################################################

ml_abs
	# if x < 0
	PUSH	-3[0]
	CONSTR	0.0
	LTR
	IFZ	ml_abs_done

	# x = -x
	CONSTR	0.0
	PUSH	-3[0]
	SUBR
	POP	-3[0]

ml_abs_done
	RET	0



##########################################################
# Functions for bounds checking array accesses
##########################################################

ml_bcheck
	PUSH -4[0]
	CONSTI 0
	LTI
	IFNZ ml_bounderror
	PUSH -4[0]
	PUSH -3[0]
	GTI
	IFNZ ml_bounderror2
	RET 0

# For array underflow
ml_bounderror
	CONSTI 69
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 79
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 58
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 66
	WRITEC
	CONSTI 79
	WRITEC
	CONSTI 85
	WRITEC
	CONSTI 78
	WRITEC
	CONSTI 68
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 85
	WRITEC
	CONSTI 70
	WRITEC
	CONSTI 10
	WRITEC
	STOP

# For array overflow
ml_bounderror2
	CONSTI 69
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 79
	WRITEC
	CONSTI 82
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 58
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 66
	WRITEC
	CONSTI 79
	WRITEC
	CONSTI 85
	WRITEC
	CONSTI 78
	WRITEC
	CONSTI 68
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 79
	WRITEC
	CONSTI 70
	WRITEC
	CONSTI 10
	WRITEC
	STOP

ml_nobcheck
	RET 0
################################################################################
# chr(x) - retrieve character value of integer
################################################################################

ml_chr
	# chr(x) is essentially a NOOP because of the way ASC handles
	# integers and characters; the two are essentially equivalent
	RET	0



##########################################
# Debug Functions
##########################################

ml_asc_dump
	!D
	RET 0

ml_asc_trace
	!T=20
	RET 0

division_zero
	CONSTI 69
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 111
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 58
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 68
	WRITEC
	CONSTI 105
	WRITEC
	CONSTI 118
	WRITEC
	CONSTI 105
	WRITEC
	CONSTI 115
	WRITEC
	CONSTI 105
	WRITEC
	CONSTI 111
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 98
	WRITEC
	CONSTI 121
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 122
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 111
	WRITEC
	CONSTI 46 
	WRITEC
	CONSTI 10
	WRITEC
	STOP


#####################################
# Function to eat until NL
####################################

ml_eat_nl
	READC
	CONSTI 10
	EQI
	IFZ ml_eat_nl
	RET 0

################################################################################
# exp(x) - return the base of natural logarithms raised to the power x 
################################################################################

# Test
#	READR
#	CALL	0, ml_exp
#	!D
#	STOP

ml_exp
	# Use Taylor Series expansion to find e^x
	# e^x = 1 + (x / 1!) + (x^2 / 2!) + (x^3 / 3!) + ...	 

	# fraction, power, i, l
	ADJUST	4	

	# fraction = x
	PUSH	-3[0]
	POP	0[0]

	# power = 1 + x
	CONSTR	1.0
	PUSH	-3[0]
	ADDR
	POP	1[0]

	# i = 1.0
	CONSTR	1.0
	POP	2[0]

	# l = 0
	CONSTR	0.0
	POP	3[0]

ml_exp_loop
	# i = i + 1
	CONSTR	1.0
	PUSH	2[0]
	ADDR
	POP	2[0]

	# fraction = fraction * ( x / i )
	PUSH	0[0]
	PUSH	-3[0]
	PUSH	2[0]
	DIVR
	MULR
	POP	0[0]

	# l = power
	PUSH	1[0]
	POP	3[0]

	# power = power + frac
	PUSH	1[0]
	PUSH	0[0]
	ADDR
	POP	1[0]

	# while (l != power)
	PUSH	3[0]
	PUSH	1[0]
	EQR
	IFZ	ml_exp_loop

ml_exp_done
	# retvalue = power
	PUSH	1[0]
	POP	-3[0]

	ADJUST	-4
	RET	0


################################################################################
## ln(x) - returns the natural log of x
################################################################################

ml_ln
	# e, n, power, left, right, area
	ADJUST	6
	
	# if x <= 0 print "Ln: Argument must be greater than 0."
	PUSH	-3[0]
	CONSTR	0
	GTR
	NOT
	IFNZ	ml_ln_error

	# e = 2.718281828459045
	CONSTR	2.718281828459045
	POP	0[0]

	# n = 0.0
	CONSTR	0.0
	POP	1[0]

	# power = x
	PUSH	-3[0]
	POP	2[0]

ml_integral_loop
	# while (power >= e)
	PUSH	2[0]
	PUSH	0[0]
	LTR
	NOT
	IFZ	ml_ln_calc

	# power = power / e
	PUSH	2[0]
	PUSH	0[0]
	DIVR
	POP	2[0]

	# n = n + 1
	PUSH	1[0]
	CONSTR	1.0
	ADDR
	POP	1[0]

	GOTO	ml_integral_loop

ml_ln_calc

	# n = n + (power / e)
	PUSH	1[0]
	PUSH	2[0]
	PUSH	0[0]
	DIVR
	ADDR
	POP	1[0]

	# power = x
	PUSH	-3[0]
	POP	2[0]

ml_ln_loop
	# area = n
	PUSH	1[0]
	POP	5[0]

	# left = ( power / Exp(n - 1.0) )
	PUSH	2[0]
	PUSH	1[0]
	CONSTR	1.0
	SUBR
	CALL	0, ml_exp
	DIVR
	POP	3[0]

	# right = ( (n - 1.0) * e )
	PUSH	0[0]
	PUSH	1[0]
	CONSTR	1.0
	SUBR
	MULR
	POP	4[0]

	# n = (L + R) / E
	PUSH	3[0]
	PUSH	4[0]
	ADDR
	PUSH	0[0]
	DIVR
	POP	1[0]

	# while (n != area)
	PUSH	1[0]
	PUSH	5[0]
	EQR
	NOT
	IFNZ	ml_ln_loop

	GOTO	ml_ln_done

ml_ln_error
	CONSTI 76
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 58
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 65
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 103
	WRITEC
	CONSTI 117
	WRITEC
	CONSTI 109
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 109
	WRITEC
	CONSTI 117
	WRITEC
	CONSTI 115
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 98
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 103
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 97
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 104
	WRITEC
	CONSTI 97
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 48
	WRITEC
	CONSTI 46
	WRITEC
	CONSTI 10
	WRITEC
	STOP

ml_ln_done
	# retvalue = n
	PUSH	1[0]
	POP	-3[0]

	ADJUST	-6
	RET	0

################################################################################
# odd(n) - return 1 if n odd, else return 0
################################################################################
ml_odd
# return n mod 2
	PUSH	-3[0]	# n
	CONSTI	2
	MOD
	POP	-3[0]
	RET 	0
################################################################################
# ord(x) - 
################################################################################

ml_ord
	# NOOP
	RET	0

################################################################################
# pred(x) - returns a value that is one less than that of x
################################################################################

ml_pred
	# x = x - 1
	PUSH	-3[0]
	CONSTR	1.0
	SUBR
	POP	-3[0]
	RET	0



#################################################
# Read string function
#################################################

ml_read_string

	CONSTI 0
	PUSH -4[0]
	PUSH -3[0]
rs_next_char
	DUP
	READC
	GOTO rs_check_end
rs_place_char
	POPI
	CONSTI 1
	ADDI
	GOTO rs_next_char
	
rs_check_end
	DUP
	CONSTI 10
	EQI
	IFNZ rs_done
	PUSH 0[0]
	PUSH 1[0]
	EQI
	IFNZ rs_done
	PUSH 0[0]
	CONSTI 1
	ADDI
	POP 0[0]
	GOTO rs_place_char
rs_done
	ADJUST -1
	CONSTI 0
	POPI
	ADJUST -3
	RET 0
#########################################
# Rounds a real to an integer
#########################################

round
	PUSH -3[0]
	DUP
	CONSTR 0
	LTR
	IFZ positive_num
	CONSTR -0.5
	ADDR
	RTOI
	POP -3[0]
	RET 0
positive_num
	CONSTR 0.5
	ADDR
	RTOI
	POP -3[0]
	RET 0

################################################################################
# sin(x) - find the value of the sine function at value x
################################################################################

# Test
	READR
	CALL	0, ml_sin
	!D
	STOP

ml_sin
	# sine function approximation using by fitting to a 
	# quadratic curve
	# http://lab.polygonal.de/?p=205 

	# result
	ADJUST	1

	# result = 0
	CONSTR	0
	POP	0[0]

	# Wrap to interval [-pi, pi]
ml_sin_lower
	# if (x < -pi)
	PUSH	-3[0] 
	CONSTR	-3.14159265
	LTR
	IFZ	ml_sin_upper

	# x = x + 2*pi
	PUSH	-3[0]
	CONSTR	6.28318531
	ADDR
	POP	-3[0]
	GOTO	ml_sin_xltz

ml_sin_upper
	# if (x > pi)
	PUSH	-3[0]
	CONSTR	3.14159265
	GTR
	IFZ	ml_sin_xltz

	# x = x - 2*pi
	PUSH	-3[0]
	CONSTR	6.28318531
	SUBR
	POP	-3[0]

ml_sin_xltz
	# if (x < 0)
	PUSH	-3[0]
	CONSTR	0.0
	LTR
	IFZ	ml_sin_xgez

	# result = 1.27323954 * x + .405284735 * x * x
	# 1.27323954 * x
	CONSTR	1.27323954
	PUSH	-3[0]
	MULR
	# 0.405284735 * x * x
	PUSH	-3[0]
	CONSTR	0.405284735
	PUSH	-3[0]
	MULR
	MULR
	# 1.27323954 * x + .405284735 * x * x
	ADDR
	POP	0[0]	
	
ml_sin_rltz_one
	# if (result < 0)
	PUSH	0[0]
	CONSTR	0.0
	LTR
	IFZ		ml_sin_rgez_one

	# sin = 0.225 * (result * -result - result) + result
	# (result * -result - result)
	PUSH	0[0]
	CONSTR	0.0
	PUSH	0[0]
	SUBR
	MULR
	PUSH	0[0]
	SUBR
	# (result * -result - result) * 0.225
	CONSTR	0.225
	MULR
	# (result * -result - result) * 0.225 + result
	PUSH	0[0]
	ADDR
	# result = ...
	POP	0[0]
	
	GOTO	ml_sin_done

ml_sin_rgez_one
	# sin = 0.225 * (result * result - result) + result
	# (result * result - result)
	PUSH	0[0]
	PUSH	0[0]
	MULR
	PUSH	0[0]
	SUBR
	# (result * -result - result) * 0.225
	CONSTR	0.225
	MULR
	# (result * -result - result) * 0.225 + result
	PUSH	0[0]
	ADDR
	# result = ...
	POP		0[0]

	GOTO	ml_sin_done

ml_sin_xgez
	# result = 1.27323954 * x - .405284735 * x * x
	# 1.27323954 * x
	CONSTR	1.27323954
	PUSH	-3[0]
	MULR
	# 0.405284735 * x * x
	PUSH	-3[0]
	CONSTR	0.405284735
	PUSH	-3[0]
	MULR
	MULR
	# 1.27323954 * x - .405284735 * x * x
	SUBR
	# result = ...
	POP	0[0]

ml_sin_rltz_two
	# if (result < 0)
	PUSH	0[0]
	CONSTR	0.0
	LTR
	IFZ	ml_sin_rgez_two

	# sin = 0.225 * (result * -result - result) + result
	# (result * -result - result)
	PUSH	0[0]
	CONSTR	0.0
	PUSH	0[0]
	SUBR
	MULR
	PUSH	0[0]
	SUBR
	# (result * -result - result) * 0.225
	CONSTR	0.225
	MULR
	# (result * -result - result) * 0.225 + result
	PUSH	0[0]
	ADDR
	# result = ...
	POP	0[0]
	
	GOTO	ml_sin_done
	
ml_sin_rgez_two
	# sin = 0.225 * (result * result - result) + result
	# (result * result - result)
	PUSH	0[0]
	PUSH	0[0]
	MULR
	PUSH	0[0]
	SUBR
	# (result * -result - result) * 0.225
	CONSTR	0.225
	MULR
	# (result * -result - result) * 0.225 + result
	PUSH	0[0]
	ADDR
	# result = ...
	POP		0[0]

ml_sin_done
	# retval = result
	PUSH	0[0]
	POP	-3[0]

	ADJUST	-1
	RET	0
################################################################################
# sqr(x) - returns the square of x
################################################################################

ml_sqr
	# x * x
	PUSH	-3[0]
	PUSH	-3[0]
	MULR

	POP	-3[0]
	RET	0


################################################################################
# sqrt(x) - returns the sqrt of x using the Bakshali Approximation
################################################################################

ml_sqrt
	# Bakshali Method
	# d = x - N^2, where N^2 is the nearest square of x
	# P = d / (2N)
	# A = N + P
	# sqrt(x) is approximately A - (P^2)/(2A) 

	# N, d, P, A, respectively
	ADJUST 	4

	# if (x == 0)
	PUSH	-3[0]
	CONSTR	0.0
	EQR
	IFZ	ml_sqrt_xlt0

	# retvalue = 0.0
	CONSTR	0.0
	GOTO	ml_sqrt_done

ml_sqrt_xlt0
	# if (x < 0) print "Sqrt: Argument cannot be negative."
	PUSH 	-3[0]
	CONSTR	0.0
	LTR
	IFNZ	ml_sqrt_error

	# N = 0
	CONSTR	0.0	
	POP	0[0]

ml_sqrt_loop
	# while ( (N*N) <= x)
	PUSH	0[0]
	PUSH	0[0]
	MULR
	PUSH	-3[0]
	GTR	
	NOT
	IFZ	ml_sqrt_calc	

	# N++
	CONSTR	1.0
	PUSH	0[0]
	ADDR
	POP	0[0]
	GOTO	ml_sqrt_loop	

ml_sqrt_calc
	# N--
	PUSH	0[0]
	CONSTR	1
	SUBR
	POP	0[0]

	# d = x - (N*N)
	PUSH	-3[0]
	PUSH	0[0]
	PUSH	0[0]
	MULR
	SUBR
	POP	1[0]

	# P = d / (2*N)
	PUSH	1[0]
	CONSTR	2.0
	PUSH	0[0]
	MULR
	DIVR
	POP	2[0]

	# A = N + P
	PUSH	0[0]
	PUSH	2[0]
	ADDR
	POP	3[0]

	# Results = A - ( (P*P) / (2*A) )
	# A
	PUSH	3[0]
	# P * P
	PUSH	2[0]
	PUSH	2[0]
	MULR
	# 2 * A
	CONSTR	2.0
	PUSH	3[0]
	MULR
	# (P*P) / (2*A)
	DIVR
	# Results = A - ( (P*P) / (2*A) )
	SUBR

	GOTO	ml_sqrt_done
ml_sqrt_error
	CONSTI 83
	WRITEC
	CONSTI 113
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 58
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 65
	WRITEC
	CONSTI 114
	WRITEC
	CONSTI 103
	WRITEC
	CONSTI 117
	WRITEC
	CONSTI 109
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 99
	WRITEC
	CONSTI 97
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 111
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 98
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 32
	WRITEC
	CONSTI 110
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 103
	WRITEC
	CONSTI 97
	WRITEC
	CONSTI 116
	WRITEC
	CONSTI 105
	WRITEC
	CONSTI 118
	WRITEC
	CONSTI 101
	WRITEC
	CONSTI 46
	WRITEC
	CONSTI 10
	WRITEC
	STOP

ml_sqrt_done
	POP	-3[0]
	ADJUST	-4
	RET	0
################################################################################
# succ(x) - Returns a value that is one greater than that of the expression x
################################################################################

ml_succ
	PUSH	-3[0]
	CONSTR	1.0
	ADDR
	POP	-3[0]
	RET	0

###############################################
# Truncate real value to integer
###############################################
	READR
	CALL 0, trunc
	WRITEI
	STOP

trunc
	PUSH -3[0]
	RTOI
	POP -3[0]
	RET 0


################################################################################
# ml_write_integer(i) writes given integer i
################################################################################
ml_write_integer

		ADJUST	1		# local var: rest

# if i < 0, write a '-' char
		PUSH	-3[0]	
		CONSTI	0
		LTI
		IFZ		if_integer_pos
		CONSTI	45
		WRITEC

# i = -i
		PUSH	-3[0]	
		CONSTI	-1
		MULI
		POP		-3[0]	

if_integer_pos

# recursively write larger digits first
# rest = i div 10
		PUSH	-3[0]	# i
		CONSTI	10
		DIVI
		POP		1[0]	# rest
# if rest > 0, write them first
		PUSH	1[0]	# rest
		IFNZ	write_larger_digits
		GOTO	write_current_digit
write_larger_digits
		PUSH	1[0]	# rest
		call	0, ml_write_integer
		ADJUST	-1
write_current_digit
# last digit = i mod 10
		PUSH	-3[0]	# i
		CONSTI	10
		MOD
# add 48 to get ascii character value
		CONSTI 	48
		ADDI
		WRITEC

		ADJUST	-1
		RET	0
################################################################################
# ml_write_string(char*) writes null terminated string
################################################################################
ml_write_string
	PUSH	-3[0]	# pointer to first char in string

write_char
	DUP
	PUSHI		# push char on stack
# check if char = 0
	DUP
	IFZ	write_string_end
# if 0, end
# else, write
	WRITEC
# advance char pointer
	CONSTI	1
	ADDI
	GOTO write_char

write_string_end
	ADJUST -2	# pop char, char address off stack
	RET	0
