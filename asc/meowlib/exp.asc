
################################################################################
# exp(x) - return the base of natural logarithms raised to the power x 
################################################################################

# Test
#	READR
#	CALL	0, ml_exp
#	!D
#	STOP

ml_exp
	# Use Taylor Series expansion to find e^x
	# e^x = 1 + (x / 1!) + (x^2 / 2!) + (x^3 / 3!) + ...	 

	# fraction, power, i, l
	ADJUST	5	
	
	# if num is less than 9.01 just return 0, starts to alternate
	# pos neg here.
	CONSTR 0.0
	CONSTR 9.01 
	SUBR
	PUSH -3[0]
	LTR
	IFZ ml_exp_zero

	# fraction = x
	PUSH	-3[0]
	POP	0[0]

	# power = 1 + x
	CONSTR	1.0
	PUSH	-3[0]
	ADDR
	POP	1[0]

	# i = 1.0
	CONSTR	1.0
	POP	2[0]

	# l = 0
	CONSTR	0.0
	POP	3[0]
	
	#max loop
	CONSTI 1000
	POP 4[0]	
	
ml_exp_loop
	# MAX LOOP REACHED EXIT
	PUSH 4[0]
	IFZ ml_exp_done

	# DECREMENT MAX LOOP BY 1
	PUSH 4[0]
	CONSTI 1
	SUBI
	POP 4[0]

	# i = i + 1
	CONSTR	1.0
	PUSH	2[0]
	ADDR
	POP	2[0]

	# fraction = fraction * ( x / i )
	PUSH	0[0]
	PUSH	-3[0]
	PUSH	2[0]
	DIVR
	MULR
	POP	0[0]

	# l = power
	PUSH	1[0]
	POP	3[0]

	# power = power + frac
	PUSH	1[0]
	PUSH	0[0]
	ADDR
	POP	1[0]

	# while (l != power)
	PUSH	3[0]
	PUSH	1[0]
	EQR
	IFZ	ml_exp_loop

ml_exp_done
	# retvalue = power
	PUSH	1[0]
	POP	-3[0]

	ADJUST	-5
	RET	0
ml_exp_zero
	# retvalue = power
	CONSTR 0.0
	POP	-3[0]

	ADJUST	-5
	RET	0

